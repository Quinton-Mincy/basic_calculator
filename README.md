# Basic Calculator

![Screen Shot 2023-03-12 at 1 46 33 PM](https://user-images.githubusercontent.com/73136662/224562730-95758fe5-f341-4059-987a-e47af1bb698f.png)

## Overview

Creating a program that performs simple calculations is complex not due to the calculations themselves. Two plus two is simple enough, but 
what about *2+2\*3*? Us devout followers of [PEMDAS](https://en.wikipedia.org/wiki/Order_of_operations) can easily see that it is 6, but what about when things get a little more complex like the expression: *2+2\*(3-(4/2))*. Still,
this may be relatively simple for us to figure out, but how do you get a computer to solve a problem like this when it is given as text? The challenge quickly becomes one of parsing user input, and presenting the expression to the basic arithmetic [operations](https://en.wikipedia.org/wiki/Operation_(mathematics)) available in most, if not all, programming languages (*+*,*-*,*\**,*/*,*%*,etc.). However, before we can utilize these operators, we need to make sure that the order of operations is conserved. It is not immediatley obvious how to do this with the format that the above expressions currently hold. Fortunately, there is another way that we can express these expressions (pun intended). 

The notation that we usually see mathematical expressions in is called [infix notation](https://en.wikipedia.org//wiki/Infix_notation). This notation is characterized by placing the operators between the [operands](https://en.wikipedia.org/wiki/Operand) that they act on. For example, in the expression *2+1*, the addition *operator* is *infixed* between the two *operands* (2 and 3). Another valid way to write this expression is in the form *22+*. This notation is called *postfix*, more famously known as [*reverse Polish notation*](https://en.wikipedia.org/wiki/Reverse_Polish_notation) (RPN). In this notation, the operator is placed after the operands that it acts on. The example we posed above (2+2\*(3-(4/2))) would be written as *2 2 3 4 2 / - \* +* (separated by spaces for clarity). This notation is very useful when we learn how to evaluate an expression in this form. As we will see, the order of operations is embedded in this notation, which is why there is no need for parenthesis. Before we learn how to evaluate an expression in this form, we will look at the algorithm used to convert an expression from infix to postfix, known as the [shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm). But first, we will briefly talk about regular expressions.

## Regular Expressions
To convert an expression from infix to postfix (RPN) notation, we must first verify that the expression is actually valid. Chiefly, it involves a concept in parsing known as [regular expressions](https://en.wikipedia.org/wiki/Regular_expression). A regular expression, or regex, is a set of finite characters or tokens that follow defined rules and/or patterns that can be used to encode and extract useful information. For example, imagine a regex used to search the body of text below for a phone numbers.

```
Need assistance creating regular expressions? Call (123) 456-7890, or visit us at 46819 E 56th between the hours of 9AM and 5PM M-F. 
```

The regular expression for phone numbers would need recognize *(123)456-7890* as a phone number and disregard all of the other numbers in the sentence. Moreover, a well written regular expression should just as easily recognize *1234567890* or *123-456-7890* as the same phone number. So in this example, the regex would define a finite set of characters *(0,1,2,3,4,5,6,7,8,9,(,),-)*, and also have a set of rules like: a phone number is 7 numbers, may or may not have parenthesis, and may or may not have hyphens. Similarly, for determining if a mathematical expression in infix notation is valid, the set of characters would be the digits *0-9*, parenthesis, and the set of operators (*+*,*-*,*\**, etc.). A few rules that goven these tokens would be: there must be an equal number of opening and closing parenthesis, an operator cannot immediatley follow another operator (*4+/2*) unless the second operator is the minus (*-*) operator immediatly followed by a number (*5\*-2*). In this second rule, the expression *5\*-2* should be interpreted as "5 multiplied by negative 2" and considered valid, while *4+/2*, or "4 plus divided by 2" does not make sense. Furthermore, the regex for an expression in RPN would require a different set of rules. 

If you want to see how I validated the users input, check the *is_valid* function in the *parser.c* folder. We will now move into shunting yard. 

## The Shunting Yard Algorithm

My implementation of the shunting yard algorithm invloves 2 data abstract data structures, a [queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)) and a [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) (similar to, but not to be confused with the [stack memory construct](https://en.wikipedia.org/wiki/Stack-based_memory_allocation)). 